package streaming

import (
	"encoding/binary"
	"testing"

	go_i2cp "github.com/go-i2p/go-i2cp"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestConnStateString verifies that ConnState.String() returns expected values.
// This is a simple sanity check for the state machine representation.
func TestConnStateString(t *testing.T) {
	tests := []struct {
		state ConnState
		want  string
	}{
		{StateInit, "INIT"},
		{StateSynSent, "SYN_SENT"},
		{StateSynRcvd, "SYN_RCVD"},
		{StateEstablished, "ESTABLISHED"},
		{StateCloseWait, "CLOSE_WAIT"},
		{StateClosing, "CLOSING"},
		{StateClosed, "CLOSED"},
		{ConnState(999), "UNKNOWN"},
	}

	for _, tt := range tests {
		t.Run(tt.want, func(t *testing.T) {
			got := tt.state.String()
			assert.Equal(t, tt.want, got, "ConnState.String()")
		})
	}
}

// TestConstants verifies that protocol constants match I2P streaming spec.
func TestConstants(t *testing.T) {
	tests := []struct {
		name string
		got  int
		want int
	}{
		{"DefaultMTU", DefaultMTU, 1730},
		{"ECIESMTU", ECIESMTU, 1812},
		{"MinMTU", MinMTU, 512},
		{"DefaultWindowSize", DefaultWindowSize, 6},
		{"MaxWindowSize", MaxWindowSize, 128},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			assert.Equal(t, tt.want, tt.got, tt.name)
		})
	}
}

// TestHashDestination tests the destination hashing function for replay prevention.
func TestHashDestination(t *testing.T) {
	t.Run("valid destination", func(t *testing.T) {
		crypto := go_i2cp.NewCrypto()
		dest, err := go_i2cp.NewDestination(crypto)
		require.NoError(t, err)

		hash, err := hashDestination(dest)
		assert.NoError(t, err)
		assert.NotNil(t, hash)
		assert.Equal(t, 32, len(hash), "SHA-256 hash should be 32 bytes")

		// Hash should be deterministic
		hash2, err := hashDestination(dest)
		assert.NoError(t, err)
		assert.Equal(t, hash, hash2, "hash should be deterministic")
	})

	t.Run("nil destination", func(t *testing.T) {
		hash, err := hashDestination(nil)
		assert.Error(t, err)
		assert.Nil(t, hash)
		assert.Contains(t, err.Error(), "nil")
	})

	t.Run("different destinations produce different hashes", func(t *testing.T) {
		crypto := go_i2cp.NewCrypto()
		dest1, err := go_i2cp.NewDestination(crypto)
		require.NoError(t, err)
		dest2, err := go_i2cp.NewDestination(crypto)
		require.NoError(t, err)

		hash1, err := hashDestination(dest1)
		require.NoError(t, err)
		hash2, err := hashDestination(dest2)
		require.NoError(t, err)

		assert.NotEqual(t, hash1, hash2, "different destinations should have different hashes")
	})

	t.Run("hash can be split into 8 uint32 values", func(t *testing.T) {
		crypto := go_i2cp.NewCrypto()
		dest, err := go_i2cp.NewDestination(crypto)
		require.NoError(t, err)

		hash, err := hashDestination(dest)
		require.NoError(t, err)

		// Extract 8 uint32 values (for NACK fields)
		nacks := make([]uint32, 8)
		for i := 0; i < 8; i++ {
			nacks[i] = binary.BigEndian.Uint32(hash[i*4 : (i+1)*4])
		}

		// Verify we got 8 values
		assert.Equal(t, 8, len(nacks))

		// Verify they're not all zeros (extremely unlikely)
		allZero := true
		for _, nack := range nacks {
			if nack != 0 {
				allZero = false
				break
			}
		}
		assert.False(t, allZero, "hash values should not all be zero")
	})
}

// TestSYNPacketStructure tests that SYN packets have the correct structure
// when generated by sendSYN (without requiring a real I2CP session).
func TestSYNPacketStructure(t *testing.T) {
	// Note: Full sendSYN testing requires a mock I2CP session
	// Here we verify the packet structure that would be generated

	t.Run("SYN packet has required fields", func(t *testing.T) {
		crypto := go_i2cp.NewCrypto()
		dest, err := go_i2cp.NewDestination(crypto)
		require.NoError(t, err)

		// Create a packet as sendSYN would
		hash, err := hashDestination(dest)
		require.NoError(t, err)

		nacks := make([]uint32, 8)
		for i := 0; i < 8; i++ {
			nacks[i] = binary.BigEndian.Uint32(hash[i*4 : (i+1)*4])
		}

		// Per I2P spec, initial SYN has NO_ACK set because ackThrough is not valid
		pkt := &Packet{
			SendStreamID:    123,
			RecvStreamID:    456,
			SequenceNum:     0,
			AckThrough:      0,
			Flags:           FlagSYN | FlagNoACK | FlagMaxPacketSizeIncluded | FlagSignatureIncluded | FlagFromIncluded,
			MaxPacketSize:   1730,
			NACKs:           nacks,
			FromDestination: dest,
		}

		// Verify packet structure - FlagNoACK is required on initial SYN per spec
		assert.Equal(t, uint16(FlagSYN|FlagNoACK|FlagMaxPacketSizeIncluded|FlagSignatureIncluded|FlagFromIncluded), pkt.Flags)
		assert.True(t, pkt.Flags&FlagNoACK != 0, "Initial SYN must have NO_ACK flag set")
		assert.Equal(t, 8, len(pkt.NACKs), "SYN should have 8 NACKs for replay prevention")
		assert.NotNil(t, pkt.FromDestination, "SYN should include FROM destination")
		assert.Equal(t, uint16(1730), pkt.MaxPacketSize)

		// Verify packet can be marshaled
		data, err := pkt.Marshal()
		assert.NoError(t, err)
		assert.NotNil(t, data)

		// Verify marshaled packet has reasonable size
		// Header (22) + NACKs (32) + Delay? (0) + MaxPacketSize (2) + FROM (391) + Signature (64) = 511+ bytes
		assert.GreaterOrEqual(t, len(data), 511, "SYN packet with all fields should be at least 511 bytes")
	})

	t.Run("NACK values are from destination hash", func(t *testing.T) {
		crypto := go_i2cp.NewCrypto()
		dest, err := go_i2cp.NewDestination(crypto)
		require.NoError(t, err)

		hash, err := hashDestination(dest)
		require.NoError(t, err)

		nacks := make([]uint32, 8)
		for i := 0; i < 8; i++ {
			nacks[i] = binary.BigEndian.Uint32(hash[i*4 : (i+1)*4])
		}

		// Verify reconstruction
		reconstructed := make([]byte, 32)
		for i, nack := range nacks {
			binary.BigEndian.PutUint32(reconstructed[i*4:(i+1)*4], nack)
		}

		assert.Equal(t, hash, reconstructed, "NACKs should reconstruct to original hash")
	})
}

// Note: I2CP session creation tests require a running I2P router.
// These will be added in Phase 1 when we implement actual I2CP operations.
// For now, we verify that the basic types and constants are correct.

// TestGenerateStreamID verifies that stream ID generation works correctly.
func TestGenerateStreamID(t *testing.T) {
	t.Run("stream ID is non-zero", func(t *testing.T) {
		id, err := generateStreamID()
		require.NoError(t, err, "generateStreamID should not return error")
		assert.Greater(t, id, uint32(0), "stream ID must be > 0")
	})

	t.Run("stream IDs are random", func(t *testing.T) {
		// Generate multiple stream IDs and verify they're different
		// Statistical test: probability of collision with 10 IDs is negligible
		ids := make(map[uint32]bool)
		count := 10
		for i := 0; i < count; i++ {
			id, err := generateStreamID()
			require.NoError(t, err, "generateStreamID should not return error")
			assert.Greater(t, id, uint32(0), "stream ID must be > 0")

			// Check for uniqueness
			assert.False(t, ids[id], "stream ID %d should be unique (collision)", id)
			ids[id] = true
		}
		assert.Equal(t, count, len(ids), "all stream IDs should be unique")
	})

	t.Run("stream IDs use full 32-bit space", func(t *testing.T) {
		// Generate many stream IDs and verify distribution across bit space
		// Test that we get values in different ranges
		count := 1000
		hasLow := false  // ID < 2^16
		hasMid := false  // 2^16 <= ID < 2^24
		hasHigh := false // ID >= 2^24

		for i := 0; i < count; i++ {
			id, err := generateStreamID()
			require.NoError(t, err, "generateStreamID should not return error")
			assert.Greater(t, id, uint32(0), "stream ID must be > 0")

			if id < (1 << 16) {
				hasLow = true
			} else if id < (1 << 24) {
				hasMid = true
			} else {
				hasHigh = true
			}

			// Early exit if we've seen all ranges
			if hasLow && hasMid && hasHigh {
				break
			}
		}

		// With 1000 random 32-bit values, we should see distribution
		// across the entire range (probability of missing a range is tiny)
		assert.True(t, hasLow || hasMid || hasHigh,
			"stream IDs should use full 32-bit space (got values in ranges: low=%v, mid=%v, high=%v)",
			hasLow, hasMid, hasHigh)
	})

	t.Run("no collisions in large sample", func(t *testing.T) {
		// Birthday paradox: with 10,000 values in 2^32 space,
		// probability of collision is ~0.01% (negligible)
		count := 10000
		ids := make(map[uint32]bool, count)

		for i := 0; i < count; i++ {
			id, err := generateStreamID()
			require.NoError(t, err, "generateStreamID should not return error")

			// Check for collision
			if ids[id] {
				t.Errorf("collision detected: stream ID %d appeared twice in %d samples", id, count)
				break
			}
			ids[id] = true
		}

		assert.Equal(t, count, len(ids), "all %d stream IDs should be unique", count)
	})
}

// TestNoACKFlagHandling verifies that the NO_ACK flag is correctly set on initial SYN
// and that ackThrough is ignored when the flag is set.
func TestNoACKFlagHandling(t *testing.T) {
	t.Run("initial SYN has NO_ACK flag set", func(t *testing.T) {
		// The buildSYNPacket function should set NO_ACK because
		// ackThrough is not valid on the initial SYN packet
		crypto := go_i2cp.NewCrypto()
		dest, err := go_i2cp.NewDestination(crypto)
		require.NoError(t, err)

		// Simulate what buildSYNPacket creates
		// Per I2P spec: initial SYN has NO_ACK set
		synFlags := FlagSYN | FlagNoACK | FlagMaxPacketSizeIncluded | FlagSignatureIncluded | FlagFromIncluded
		pkt := &Packet{
			SendStreamID:    0, // Always 0 for initial SYN
			RecvStreamID:    12345,
			SequenceNum:     0,
			AckThrough:      0, // Not valid - NO_ACK tells peer to ignore
			Flags:           synFlags,
			MaxPacketSize:   DefaultMTU,
			FromDestination: dest,
		}

		assert.True(t, pkt.Flags&FlagSYN != 0, "SYN flag should be set")
		assert.True(t, pkt.Flags&FlagNoACK != 0, "NO_ACK flag should be set on initial SYN")

		// Marshal and unmarshal to verify flags survive round-trip
		data, err := pkt.Marshal()
		require.NoError(t, err)

		unmarshaled := &Packet{}
		err = unmarshaled.Unmarshal(data)
		require.NoError(t, err)

		assert.True(t, unmarshaled.Flags&FlagNoACK != 0,
			"NO_ACK flag should survive marshal/unmarshal")
	})

	t.Run("SYN-ACK does NOT have NO_ACK flag", func(t *testing.T) {
		// SYN-ACK is a response that acknowledges the peer's SYN,
		// so it should NOT have NO_ACK set
		crypto := go_i2cp.NewCrypto()
		dest, err := go_i2cp.NewDestination(crypto)
		require.NoError(t, err)

		// Simulate what buildSynAckPacket creates
		synAckFlags := FlagSYN | FlagMaxPacketSizeIncluded | FlagSignatureIncluded | FlagFromIncluded
		pkt := &Packet{
			SendStreamID:    12345, // Non-zero for SYN-ACK
			RecvStreamID:    54321,
			SequenceNum:     100,
			AckThrough:      0, // Valid - acknowledges peer's SYN
			Flags:           synAckFlags,
			MaxPacketSize:   DefaultMTU,
			FromDestination: dest,
		}

		assert.True(t, pkt.Flags&FlagSYN != 0, "SYN flag should be set")
		assert.False(t, pkt.Flags&FlagNoACK != 0, "NO_ACK flag should NOT be set on SYN-ACK")
	})

	t.Run("data packets do NOT have NO_ACK flag", func(t *testing.T) {
		// Regular data packets always have valid ackThrough
		pkt := &Packet{
			SendStreamID: 12345,
			RecvStreamID: 54321,
			SequenceNum:  101,
			AckThrough:   100,
			Flags:        0, // No flags - data packets use ackThrough directly
			Payload:      []byte("hello"),
		}

		assert.False(t, pkt.Flags&FlagNoACK != 0,
			"NO_ACK flag should NOT be set on data packets")
	})
}
