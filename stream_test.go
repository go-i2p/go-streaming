package streaming

import (
	"encoding/binary"
	"testing"

	go_i2cp "github.com/go-i2p/go-i2cp"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestConnStateString verifies that ConnState.String() returns expected values.
// This is a simple sanity check for the state machine representation.
func TestConnStateString(t *testing.T) {
	tests := []struct {
		state ConnState
		want  string
	}{
		{StateInit, "INIT"},
		{StateSynSent, "SYN_SENT"},
		{StateSynRcvd, "SYN_RCVD"},
		{StateEstablished, "ESTABLISHED"},
		{StateCloseWait, "CLOSE_WAIT"},
		{StateClosing, "CLOSING"},
		{StateClosed, "CLOSED"},
		{ConnState(999), "UNKNOWN"},
	}

	for _, tt := range tests {
		t.Run(tt.want, func(t *testing.T) {
			got := tt.state.String()
			assert.Equal(t, tt.want, got, "ConnState.String()")
		})
	}
}

// TestConstants verifies that protocol constants match I2P streaming spec.
func TestConstants(t *testing.T) {
	tests := []struct {
		name string
		got  int
		want int
	}{
		{"DefaultMTU", DefaultMTU, 1730},
		{"ECIESMTU", ECIESMTU, 1812},
		{"MinMTU", MinMTU, 512},
		{"DefaultWindowSize", DefaultWindowSize, 6},
		{"MaxWindowSize", MaxWindowSize, 128},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			assert.Equal(t, tt.want, tt.got, tt.name)
		})
	}
}

// TestHashDestination tests the destination hashing function for replay prevention.
func TestHashDestination(t *testing.T) {
	t.Run("valid destination", func(t *testing.T) {
		crypto := go_i2cp.NewCrypto()
		dest, err := go_i2cp.NewDestination(crypto)
		require.NoError(t, err)

		hash, err := hashDestination(dest)
		assert.NoError(t, err)
		assert.NotNil(t, hash)
		assert.Equal(t, 32, len(hash), "SHA-256 hash should be 32 bytes")

		// Hash should be deterministic
		hash2, err := hashDestination(dest)
		assert.NoError(t, err)
		assert.Equal(t, hash, hash2, "hash should be deterministic")
	})

	t.Run("nil destination", func(t *testing.T) {
		hash, err := hashDestination(nil)
		assert.Error(t, err)
		assert.Nil(t, hash)
		assert.Contains(t, err.Error(), "nil")
	})

	t.Run("different destinations produce different hashes", func(t *testing.T) {
		crypto := go_i2cp.NewCrypto()
		dest1, err := go_i2cp.NewDestination(crypto)
		require.NoError(t, err)
		dest2, err := go_i2cp.NewDestination(crypto)
		require.NoError(t, err)

		hash1, err := hashDestination(dest1)
		require.NoError(t, err)
		hash2, err := hashDestination(dest2)
		require.NoError(t, err)

		assert.NotEqual(t, hash1, hash2, "different destinations should have different hashes")
	})

	t.Run("hash can be split into 8 uint32 values", func(t *testing.T) {
		crypto := go_i2cp.NewCrypto()
		dest, err := go_i2cp.NewDestination(crypto)
		require.NoError(t, err)

		hash, err := hashDestination(dest)
		require.NoError(t, err)

		// Extract 8 uint32 values (for NACK fields)
		nacks := make([]uint32, 8)
		for i := 0; i < 8; i++ {
			nacks[i] = binary.BigEndian.Uint32(hash[i*4 : (i+1)*4])
		}

		// Verify we got 8 values
		assert.Equal(t, 8, len(nacks))

		// Verify they're not all zeros (extremely unlikely)
		allZero := true
		for _, nack := range nacks {
			if nack != 0 {
				allZero = false
				break
			}
		}
		assert.False(t, allZero, "hash values should not all be zero")
	})
}

// TestSYNPacketStructure tests that SYN packets have the correct structure
// when generated by sendSYN (without requiring a real I2CP session).
func TestSYNPacketStructure(t *testing.T) {
	// Note: Full sendSYN testing requires a mock I2CP session
	// Here we verify the packet structure that would be generated

	t.Run("SYN packet has required fields", func(t *testing.T) {
		crypto := go_i2cp.NewCrypto()
		dest, err := go_i2cp.NewDestination(crypto)
		require.NoError(t, err)

		// Create a packet as sendSYN would
		hash, err := hashDestination(dest)
		require.NoError(t, err)

		nacks := make([]uint32, 8)
		for i := 0; i < 8; i++ {
			nacks[i] = binary.BigEndian.Uint32(hash[i*4 : (i+1)*4])
		}

		pkt := &Packet{
			SendStreamID:    123,
			RecvStreamID:    456,
			SequenceNum:     0,
			AckThrough:      0,
			Flags:           FlagSYN | FlagMaxPacketSizeIncluded | FlagSignatureIncluded | FlagFromIncluded,
			MaxPacketSize:   1730,
			NACKs:           nacks,
			FromDestination: dest,
		}

		// Verify packet structure
		assert.Equal(t, uint16(FlagSYN|FlagMaxPacketSizeIncluded|FlagSignatureIncluded|FlagFromIncluded), pkt.Flags)
		assert.Equal(t, 8, len(pkt.NACKs), "SYN should have 8 NACKs for replay prevention")
		assert.NotNil(t, pkt.FromDestination, "SYN should include FROM destination")
		assert.Equal(t, uint16(1730), pkt.MaxPacketSize)

		// Verify packet can be marshaled
		data, err := pkt.Marshal()
		assert.NoError(t, err)
		assert.NotNil(t, data)

		// Verify marshaled packet has reasonable size
		// Header (22) + NACKs (32) + Delay? (0) + MaxPacketSize (2) + FROM (391) + Signature (64) = 511+ bytes
		assert.GreaterOrEqual(t, len(data), 511, "SYN packet with all fields should be at least 511 bytes")
	})

	t.Run("NACK values are from destination hash", func(t *testing.T) {
		crypto := go_i2cp.NewCrypto()
		dest, err := go_i2cp.NewDestination(crypto)
		require.NoError(t, err)

		hash, err := hashDestination(dest)
		require.NoError(t, err)

		nacks := make([]uint32, 8)
		for i := 0; i < 8; i++ {
			nacks[i] = binary.BigEndian.Uint32(hash[i*4 : (i+1)*4])
		}

		// Verify reconstruction
		reconstructed := make([]byte, 32)
		for i, nack := range nacks {
			binary.BigEndian.PutUint32(reconstructed[i*4:(i+1)*4], nack)
		}

		assert.Equal(t, hash, reconstructed, "NACKs should reconstruct to original hash")
	})
}

// Note: I2CP session creation tests require a running I2P router.
// These will be added in Phase 1 when we implement actual I2CP operations.
// For now, we verify that the basic types and constants are correct.

// TestGenerateStreamID verifies that stream ID generation works correctly.
func TestGenerateStreamID(t *testing.T) {
	t.Run("stream ID is non-zero", func(t *testing.T) {
		id, err := generateStreamID()
		require.NoError(t, err, "generateStreamID should not return error")
		assert.Greater(t, id, uint32(0), "stream ID must be > 0")
	})

	t.Run("stream IDs are random", func(t *testing.T) {
		// Generate multiple stream IDs and verify they're different
		// Statistical test: probability of collision with 10 IDs is negligible
		ids := make(map[uint32]bool)
		count := 10
		for i := 0; i < count; i++ {
			id, err := generateStreamID()
			require.NoError(t, err, "generateStreamID should not return error")
			assert.Greater(t, id, uint32(0), "stream ID must be > 0")

			// Check for uniqueness
			assert.False(t, ids[id], "stream ID %d should be unique (collision)", id)
			ids[id] = true
		}
		assert.Equal(t, count, len(ids), "all stream IDs should be unique")
	})

	t.Run("stream IDs use full 32-bit space", func(t *testing.T) {
		// Generate many stream IDs and verify distribution across bit space
		// Test that we get values in different ranges
		count := 1000
		hasLow := false  // ID < 2^16
		hasMid := false  // 2^16 <= ID < 2^24
		hasHigh := false // ID >= 2^24

		for i := 0; i < count; i++ {
			id, err := generateStreamID()
			require.NoError(t, err, "generateStreamID should not return error")
			assert.Greater(t, id, uint32(0), "stream ID must be > 0")

			if id < (1 << 16) {
				hasLow = true
			} else if id < (1 << 24) {
				hasMid = true
			} else {
				hasHigh = true
			}

			// Early exit if we've seen all ranges
			if hasLow && hasMid && hasHigh {
				break
			}
		}

		// With 1000 random 32-bit values, we should see distribution
		// across the entire range (probability of missing a range is tiny)
		assert.True(t, hasLow || hasMid || hasHigh,
			"stream IDs should use full 32-bit space (got values in ranges: low=%v, mid=%v, high=%v)",
			hasLow, hasMid, hasHigh)
	})

	t.Run("no collisions in large sample", func(t *testing.T) {
		// Birthday paradox: with 10,000 values in 2^32 space,
		// probability of collision is ~0.01% (negligible)
		count := 10000
		ids := make(map[uint32]bool, count)

		for i := 0; i < count; i++ {
			id, err := generateStreamID()
			require.NoError(t, err, "generateStreamID should not return error")

			// Check for collision
			if ids[id] {
				t.Errorf("collision detected: stream ID %d appeared twice in %d samples", id, count)
				break
			}
			ids[id] = true
		}

		assert.Equal(t, count, len(ids), "all %d stream IDs should be unique", count)
	})
}
